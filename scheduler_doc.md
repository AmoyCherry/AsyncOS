# 调度器运行

调度器作是内核和用户共享的.调度器会被编译成elf可执行文件.同时映射在了内核和用户空间中. 内核和用户通过jp addr形式调用其中函数.

后续:vDSO形式提供给用户程序.当前rust语言针对riscv平台缺乏动态链接的支持.现在目前这部分还未和linux中的一致.

可能的办法:手动写stub函数...

# 调度器在内核态(启用内核页表隔离机制 kpti)

某一时刻,系统中,进程,线程,协程的状态.

一个内核进程(内核本身)

多个常驻内核态的内核协程(均由调度器接口创建)

多个用户进程(由内核提供的接口创建),每个用户进程下包含多个用户线程(由调度器接口创建),每个用户线程下由多个用户协程(由调度器接口创建),这些用户进程会在运行时不断在用户进程与内核进程中反复横跳

注：内核调度器与用户态的调度器的区别：协程的退出操作会不同（最后一个内核协程退出会进入IDLE）

# 2.1. 调度的对象

**用户进程 内核线程 内核协程 用户线程 用户协程(不直接参与调度)**

# 2.2 调度的目标

优化协程实时性问题. (能让协程调度器感知到存在着比自己紧急的任务), 让紧急事件得到处理

more:还需细化


优化协程实时性问题:

需要内核以某种方式参与协程调度. 这要求内核维护全部或部分协程信息(如优先级).

以内核维护协程信息的不同分两种情况:

1.内核和用户共享协程队列

- tornado-os的做法.这时候协程执行器,可以放在内核中.用线程包装协程提供强制切换的可能

2.内核仅维护部分协程信息

- 内核只有每个进程下最高优先级协程的优先级.
- 
- 内核调度协程的方式只能是调度协程所在的线程或者进程
- 
- 协程执行器中获取下一个任务时,检查内核提供的调度信息.

参考linux O(1)调度算法中的位图

1.每个用户进程下都维护一个位图. 每一位代表当前进程下相关优先级协程队列是否为空. 同时内核也维护一个位图.

2.在时钟中断进入内核时,内核将所有用户进程下的位图和内核中的位图做或运算.更新内核中的位图

3.用户在调度自己的协程时,会将内核提供的位图和自己的位图做比较,看是否有比自己优先级更高的协程存在. 如果有,则可以选择主动让出.


# 2.3. 各对象具体的调度方式

1.用户进程队列,内核线程队列,内核协程队列,与内核在同一页表下,内核可以直接拿到其数据

2.用户线程,用户协程与内核属于不同地址空间

**用户进程**
目前执行一个调度循环. 不断从进程队列中取出进程执行

todo:进程不再是调度的单位

**内核线程**
内核线程平时执行一个idle_main,  idle_main不断从线程池中获取一个可运行的线程.

当线程池没有任何可运行的线程,则会检查协程队列,如果还有协程新加入,则创建一个线程包含协程执行器继续运行, 如果空,则退出.

退出方式:

1.继续运行idle_main

2.使当前cpu进入低功耗状态(spin_loop)

**内核协程**
内核协程主要执行异步系统调用,并根据实时性要求不同设置不同的优先级.由协程runtime调度.

todo:时钟中断到来时检查用户线程是否需要让权（其他用户线程中是否有优先级更高的协程

**用户线程**
用户线程为内核参与用户协程调度的载体. 内核需处理用户线程退出的情况,回收其cpu资源.

**用户协程**
获取最高优先级协程所在的地址空间. 并且提示下一个用户线程, 让它主动让出cpu,这便少了一次堆栈的保存和恢复.  可能的情况---最高优先级协程所在线程已经占有cpu资源

# 调度器在用户态

向内核提供最高优先级协程信息.
